# C语言指针

# 理解

## 声明

可以理解为一种数据类型，**相当于变量**，声明方式在普通变量的情况下在变量名前再加入一个“*”

## 存储

可以存储**其它变量的地址**，格式是在变量名前加一个“&”

赋值的时候指针变量前不用加“*”

## 使用

指针指向变量，所以可以用指针前加“*”表示变量的值，而指针名前不加“*”则可以表示地址

**单个名称表示地址，前加“*”表示地址存储的值**

### 指针变量基础操作（摘自C primer plus第687页）

> 赋值：可以把地址赋给指针。例如，用数组名、带地址运算符（&）的
变量名、另一个指针进行赋值。在该例中，把urn数组的首地址赋给了ptr1，
该地址的编号恰好是0x7fff5fbff8d0。变量ptr2获得数组urn的第3个元素
（urn[2]）的地址。注意，地址应该和指针类型兼容。也就是说，不能把
double类型的地址赋给指向int的指针，至少要避免不明智的类型转换。
C99/C11已经强制不允许这样做。
解引用：*运算符给出指针指向地址上储存的值。因此，*ptr1的初值是
100，该值储存在编号为0x7fff5fbff8d0的地址上。
取址：和所有变量一样，指针变量也有自己的地址和值。对指针而言，
&运算符给出指针本身的地址。本例中，ptr1 储存在内存编号为
0x7fff5fbff8c8 的地址上，该存储单元储存的内容是0x7fff5fbff8d0，即urn的地
址。因此&ptr1是指向ptr1的指针，而ptr1是指向utn[0]的指针。
指针与整数相加：可以使用+运算符把指针与整数相加，或整数与指针
相加。无论哪种情况，整数都会和指针所指向类型的大小（以字节为单位）
相乘，然后把结果与初始地址相加。因此ptr1 +4与&urn[4]等价。如果相加
的结果超出了初始指针指向的数组范围，计算结果则是未定义的。除非正好
超过数组末尾第一个位置，C保证该指针有效。
递增指针：递增指向数组元素的指针可以让该指针移动至数组的下一个
元素。因此，ptr1++相当于把ptr1的值加上4（我们的系统中int为4字节），
ptr1指向urn[1]（见图10.4，该图中使用了简化的地址）。现在ptr1的值是
0x7fff5fbff8d4（数组的下一个元素的地址），*ptr的值为200（即urn[1]的
值）。注意，ptr1本身的地址仍是 0x7fff5fbff8c8。毕竟，变量不会因为值发
生变化就移动位置。
685图10.4 递增指向int的指针
指针减去一个整数：可以使用-运算符从一个指针中减去一个整数。指
针必须是第1个运算对象，整数是第 2 个运算对象。该整数将乘以指针指向
类型的大小（以字节为单位），然后用初始地址减去乘积。所以ptr3 - 2与
&urn[2]等价，因为ptr3指向的是&arn[4]。如果相减的结果超出了初始指针所
指向数组的范围，计算结果则是未定义的。除非正好超过数组末尾第一个位
置，C保证该指针有效。
递减指针：当然，除了递增指针还可以递减指针。在本例中，递减ptr3
使其指向数组的第2个元素而不是第3个元素。前缀或后缀的递增和递减运算
符都可以使用。注意，在重置ptr1和ptr2前，它们都指向相同的元素urn[1]。
指针求差：可以计算两个指针的差值。通常，求差的两个指针分别指向
同一个数组的不同元素，通过计算求出两元素之间的距离。差值的单位与数
组类型的单位相同。例如，程序清单10.13的输出中，ptr2 - ptr1得2，意思是
这两个指针所指向的两个元素相隔两个int，而不是2字节。只要两个指针都
指向相同的数组（或者其中一个指针指向数组后面的第 1 个地址），C 都能
保证相减运算有效。如果指向两个不同数组的指针进行求差运算可能会得出
一个值，或者导致运行时错误。
比较：使用关系运算符可以比较两个指针的值，前提是两个指针都指向
686相同类型的对象。
> 

# 数组

同一数组内元素的机器地址是连续的，可以通过把数组地址赋值给指针，做加法即可得到数组各元素的地址

```c
short dates[SIZE];
short * pti;
short index;
double bills[SIZE];
double * ptf;
pti = dates; // 把数组地址赋给指针
ptf = bills;

//下面的等式体现了C语言的灵活性：
dates + 2 == &date[2] // 相同的地址
*(dates + 2) == dates[2] // 相同的值
```